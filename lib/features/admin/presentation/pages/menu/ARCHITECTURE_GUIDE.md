# ğŸ—ï¸ Ø¯Ù„ÙŠÙ„ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ© - Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©

## ğŸ“‹ **Ù†Ø¸Ø±Ø© Ø¹Ø§Ù…Ø©**

Ù‡Ø°Ø§ Ø§Ù„Ø¯Ù„ÙŠÙ„ ÙŠØ´Ø±Ø­ Ø§Ù„Ø¨Ù†ÙŠØ© Ø§Ù„Ù…Ø¹Ù…Ø§Ø±ÙŠØ© Ø§Ù„ÙƒØ§Ù…Ù„Ø© Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©ØŒ Ù…Ù† Data Layer Ø¥Ù„Ù‰ Presentation LayerØŒ Ù…Ø¹ Ø´Ø±Ø­ ÙƒÙ„ Ø·Ø¨Ù‚Ø© ÙˆÙ…Ø³Ø¤ÙˆÙ„ÙŠØ§ØªÙ‡Ø§ ÙˆØ§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ù…Ø·Ø¨Ù‚Ø©.

---

## ğŸ”— **Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ù…Ø¹ Ù†Ø¸Ø§Ù… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª (Add Items System)**

### **ğŸ¯ Ø§Ù„Ø¹Ù„Ø§Ù‚Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©:**

**`menu/`** Ùˆ **`add_items/`** Ù‡Ù…Ø§ Ù…ÙƒÙˆÙ†Ø§Ù† Ù…ØªÙƒØ§Ù…Ù„Ø§Ù† ÙÙŠ Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø·Ø¹Ù…:

#### **1. Ø§Ù„ØªØ¯ÙÙ‚ Ø§Ù„Ù…Ù†Ø·Ù‚ÙŠ:**
```
ğŸ“ Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬ Ø¬Ø¯ÙŠØ¯ (add_items/) 
    â†“
ğŸ’¾ Ø­ÙØ¸ ÙÙŠ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    â†“
ğŸ“‹ Ø¹Ø±Ø¶ ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© (menu/)
```

#### **2. Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ§Øª Ø§Ù„Ù…ØªØ¨Ø§ÙŠÙ†Ø©:**

**`menu/` (Ù†Ø¸Ø§Ù… Ø§Ù„Ø¹Ø±Ø¶):**
- âœ… **Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ù…Ø¶Ø§ÙØ©** - Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
- âœ… **ØªØµÙÙŠØ© Ø­Ø³Ø¨ Ø§Ù„ÙØ¦Ø§Øª** - ØªØµÙÙŠØ© ÙˆØ¨Ø­Ø«
- âœ… **ØªØ¹Ø¯ÙŠÙ„ ÙˆØ­Ø°Ù Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª** - Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ø§Ù„Ù…ÙˆØ¬ÙˆØ¯Ø©
- âœ… **Ø¥Ø¯Ø§Ø±Ø© Ø­Ø§Ù„Ø© Ø§Ù„ØªÙˆÙØ±** - ØªØºÙŠÙŠØ± Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ù†ØªØ¬

**`add_items/` (Ù†Ø¸Ø§Ù… Ø§Ù„Ø¥Ø¶Ø§ÙØ©):**
- âœ… **Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù†ØªØ¬Ø§Øª Ø¬Ø¯ÙŠØ¯Ø©** - Ù†Ù…ÙˆØ°Ø¬ ØªÙØµÙŠÙ„ÙŠ
- âœ… **ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±** - Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±
- âœ… **Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„ÙØ¦Ø§Øª** - ØªØ­Ø¯ÙŠØ¯ Ø§Ù„ÙØ¦Ø§Øª
- âœ… **Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„ØªÙˆÙØ±** - ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø­Ø§Ù„Ø©

#### **3. Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª:**

**API Endpoints Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©:**
- `GET /admin/products` - Ø¬Ù„Ø¨ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª (menu/)
- `POST /admin/products` - Ø¥Ø¶Ø§ÙØ© Ù…Ù†ØªØ¬ (add_items/)
- `PUT /admin/products/{id}` - ØªØ­Ø¯ÙŠØ« Ù…Ù†ØªØ¬ (menu/)
- `DELETE /admin/products/{id}` - Ø­Ø°Ù Ù…Ù†ØªØ¬ (menu/)

**Data Models Ø§Ù„Ù…Ø´ØªØ±ÙƒØ©:**
- `Product` Entity - Ø§Ù„ÙƒÙŠØ§Ù† Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
- `ProductModel` - Ù†Ù…ÙˆØ°Ø¬ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
- `ProductRepository` - ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªÙˆØ¯Ø¹

---

## ğŸ—‚ï¸ **Ù‡ÙŠÙƒÙ„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø­Ø³Ù†**

```
lib/features/admin/presentation/pages/menu/
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ menu_item_model.dart          # Data Model
â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â””â”€â”€ menu_repository_impl.dart     # Repository Implementation
â”‚   â””â”€â”€ datasources/
â”‚       â””â”€â”€ menu_remote_data_source.dart  # API Calls
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â””â”€â”€ menu_item.dart                # Business Entity
â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â””â”€â”€ menu_repository.dart          # Repository Interface
â”‚   â””â”€â”€ usecases/                         # Business Logic (Ù…Ø­Ø³Ù†)
â”‚       â”œâ”€â”€ load_menu_items_usecase.dart  # ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª
â”‚       â”œâ”€â”€ load_menu_items_by_category_usecase.dart  # ØªØ­Ù…ÙŠÙ„ Ø­Ø³Ø¨ Ø§Ù„ÙØ¦Ø©
â”‚       â”œâ”€â”€ search_menu_items_usecase.dart  # Ø§Ù„Ø¨Ø­Ø«
â”‚       â”œâ”€â”€ delete_menu_item_usecase.dart  # Ø­Ø°Ù Ù…Ù†ØªØ¬
â”‚       â””â”€â”€ toggle_menu_item_availability_usecase.dart  # ØªØºÙŠÙŠØ± Ø§Ù„ØªÙˆÙØ±
â””â”€â”€ presentation/
    â”œâ”€â”€ cubit/
    â”‚   â”œâ”€â”€ menu_cubit.dart               # State Management (Ù…Ø­Ø³Ù†)
    â”‚   â”œâ”€â”€ menu_events.dart              # Events (Ù…Ø­Ø³Ù†)
    â”‚   â””â”€â”€ menu_states.dart              # States (Ù…Ø­Ø³Ù†)
    â”œâ”€â”€ pages/
    â”‚   â””â”€â”€ admin_menu_page.dart          # UI (Ù…Ø­Ø³Ù†)
    â””â”€â”€ widgets/
        â”œâ”€â”€ menu_filter_tabs.dart         # ØªØµÙÙŠØ© Ø§Ù„ÙØ¦Ø§Øª
        â”œâ”€â”€ menu_item_card.dart           # Ø¨Ø·Ø§Ù‚Ø© Ø§Ù„Ù…Ù†ØªØ¬
        â””â”€â”€ custom_bottom_navigation.dart # Ø§Ù„ØªÙ†Ù‚Ù„ Ø§Ù„Ø³ÙÙ„ÙŠ
```

---

## ğŸ—„ï¸ **1. Domain Layer (Ø·Ø¨Ù‚Ø© Ø§Ù„Ù†Ø·Ø§Ù‚)**

### ğŸ“Š **1.1 Business Entities**

**Ø§Ù„Ù…Ù„Ù:** `domain/entities/menu_item.dart`

```dart
class MenuItem {
  const MenuItem({
    required this.id,
    required this.name,
    required this.category,
    required this.rating,
    required this.reviewCount,
    required this.price,
    required this.imagePath,
    this.description,
    this.isAvailable = true,
  });

  final String id;
  final String name;
  final String category;
  final double rating;
  final int reviewCount;
  final String price;
  final String imagePath;
  final String? description;
  final bool isAvailable;

  // âœ… Business Logic Methods
  bool get isValid => name.isNotEmpty && price.isNotEmpty;
  String get formattedPrice => '\$$price';
  String get ratingText => '$rating (${reviewCount} reviews)';
  bool get isExpensive => double.tryParse(price) ?? 0 > 20;
  bool get isPopular => rating >= 4.0 && reviewCount >= 10;

  // âœ… Copy With Method
  MenuItem copyWith({
    String? id,
    String? name,
    String? category,
    double? rating,
    int? reviewCount,
    String? price,
    String? imagePath,
    String? description,
    bool? isAvailable,
  }) {
    return MenuItem(
      id: id ?? this.id,
      name: name ?? this.name,
      category: category ?? this.category,
      rating: rating ?? this.rating,
      reviewCount: reviewCount ?? this.reviewCount,
      price: price ?? this.price,
      imagePath: imagePath ?? this.imagePath,
      description: description ?? this.description,
      isAvailable: isAvailable ?? this.isAvailable,
    );
  }
}
```

### ğŸ”§ **1.2 Repository Interface**

**Ø§Ù„Ù…Ù„Ù:** `domain/repositories/menu_repository.dart`

```dart
abstract class MenuRepository {
  /// Get all menu items
  Future<List<MenuItem>> getMenuItems();

  /// Get menu items by category
  Future<List<MenuItem>> getMenuItemsByCategory(String category);

  /// Get a single menu item by ID
  Future<MenuItem?> getMenuItemById(String id);

  /// Add a new menu item
  Future<MenuItem> addMenuItem(MenuItem menuItem);

  /// Update an existing menu item
  Future<MenuItem> updateMenuItem(MenuItem menuItem);

  /// Delete a menu item
  Future<bool> deleteMenuItem(String id);

  /// Search menu items by name
  Future<List<MenuItem>> searchMenuItems(String query);

  /// Get available categories
  Future<List<String>> getCategories();
}
```

### ğŸ¯ **1.3 Use Cases (Ù…Ø­Ø³Ù†)**

**Ø§Ù„Ù…Ù„Ù:** `domain/usecases/load_menu_items_usecase.dart`

```dart
class LoadMenuItemsUseCase {
  final MenuRepository repository;

  LoadMenuItemsUseCase({required this.repository});

  Future<List<MenuItem>> call() async {
    try {
      return await repository.getMenuItems();
    } catch (e) {
      throw Exception('ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª: $e');
    }
  }
}
```

**Ø§Ù„Ù…Ù„Ù:** `domain/usecases/load_menu_items_by_category_usecase.dart`

```dart
class LoadMenuItemsByCategoryParams {
  final String category;
  const LoadMenuItemsByCategoryParams({required this.category});
}

class LoadMenuItemsByCategoryUseCase {
  final MenuRepository repository;

  LoadMenuItemsByCategoryUseCase({required this.repository});

  Future<List<MenuItem>> call(LoadMenuItemsByCategoryParams params) async {
    try {
      if (params.category.isEmpty) {
        throw Exception('Ø§Ø³Ù… Ø§Ù„ÙØ¦Ø© Ù…Ø·Ù„ÙˆØ¨');
      }
      
      return await repository.getMenuItemsByCategory(params.category);
    } catch (e) {
      throw Exception('ÙØ´Ù„ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª Ù„Ù„ÙØ¦Ø© ${params.category}: $e');
    }
  }
}
```

**Ø§Ù„Ù…Ù„Ù:** `domain/usecases/search_menu_items_usecase.dart`

```dart
class SearchMenuItemsParams {
  final String query;
  const SearchMenuItemsParams({required this.query});
}

class SearchMenuItemsUseCase {
  final MenuRepository repository;

  SearchMenuItemsUseCase({required this.repository});

  Future<List<MenuItem>> call(SearchMenuItemsParams params) async {
    try {
      if (params.query.trim().isEmpty) {
        throw Exception('Ù†Øµ Ø§Ù„Ø¨Ø­Ø« Ù…Ø·Ù„ÙˆØ¨');
      }
      
      if (params.query.trim().length < 2) {
        throw Exception('Ù†Øµ Ø§Ù„Ø¨Ø­Ø« ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„ Ø­Ø±ÙÙŠÙ†');
      }
      
      return await repository.searchMenuItems(params.query.trim());
    } catch (e) {
      throw Exception('ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª: $e');
    }
  }
}
```

**Ø§Ù„Ù…Ù„Ù:** `domain/usecases/delete_menu_item_usecase.dart`

```dart
class DeleteMenuItemParams {
  final String id;
  const DeleteMenuItemParams({required this.id});
}

class DeleteMenuItemUseCase {
  final MenuRepository repository;

  DeleteMenuItemUseCase({required this.repository});

  Future<bool> call(DeleteMenuItemParams params) async {
    try {
      if (params.id.isEmpty) {
        throw Exception('Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ù†ØªØ¬ Ù…Ø·Ù„ÙˆØ¨');
      }
      
      return await repository.deleteMenuItem(params.id);
    } catch (e) {
      throw Exception('ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ù†ØªØ¬: $e');
    }
  }
}
```

**Ø§Ù„Ù…Ù„Ù:** `domain/usecases/toggle_menu_item_availability_usecase.dart`

```dart
class ToggleMenuItemAvailabilityParams {
  final String id;
  final bool isAvailable;

  const ToggleMenuItemAvailabilityParams({
    required this.id,
    required this.isAvailable,
  });
}

class ToggleMenuItemAvailabilityUseCase {
  final MenuRepository repository;

  ToggleMenuItemAvailabilityUseCase({required this.repository});

  Future<MenuItem> call(ToggleMenuItemAvailabilityParams params) async {
    try {
      if (params.id.isEmpty) {
        throw Exception('Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ù†ØªØ¬ Ù…Ø·Ù„ÙˆØ¨');
      }
      
      // Get current menu item
      final currentItem = await repository.getMenuItemById(params.id);
      if (currentItem == null) {
        throw Exception('Ø§Ù„Ù…Ù†ØªØ¬ ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯');
      }
      
      // Create updated item with new availability
      final updatedItem = currentItem.copyWith(isAvailable: params.isAvailable);
      
      // Update the item
      return await repository.updateMenuItem(updatedItem);
    } catch (e) {
      throw Exception('ÙØ´Ù„ ÙÙŠ ØªØºÙŠÙŠØ± Ø­Ø§Ù„Ø© ØªÙˆÙØ± Ø§Ù„Ù…Ù†ØªØ¬: $e');
    }
  }
}
```

---

## ğŸ“Š **2. Data Layer (Ø·Ø¨Ù‚Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª)**

### ğŸ“‹ **2.1 Data Models**

**Ø§Ù„Ù…Ù„Ù:** `data/models/menu_item_model.dart`

```dart
class MenuItemModel {
  final String id;
  final String name;
  final String category;
  final double rating;
  final int reviewCount;
  final String price;
  final String imagePath;
  final String? description;
  final bool isAvailable;

  const MenuItemModel({
    required this.id,
    required this.name,
    required this.category,
    required this.rating,
    required this.reviewCount,
    required this.price,
    required this.imagePath,
    this.description,
    this.isAvailable = true,
  });

  // âœ… Factory Methods Ù„Ù„ØªØ­ÙˆÙŠÙ„
  factory MenuItemModel.fromJson(Map<String, dynamic> json) {
    return MenuItemModel(
      id: json['id']?.toString() ?? '',
      name: json['name'] ?? '',
      category: json['category'] ?? '',
      rating: (json['rating'] ?? 0.0).toDouble(),
      reviewCount: json['review_count'] ?? 0,
      price: json['price']?.toString() ?? '0',
      imagePath: json['image_path'] ?? '',
      description: json['description'],
      isAvailable: json['is_available'] ?? true,
    );
  }

  factory MenuItemModel.fromEntity(MenuItem entity) {
    return MenuItemModel(
      id: entity.id,
      name: entity.name,
      category: entity.category,
      rating: entity.rating,
      reviewCount: entity.reviewCount,
      price: entity.price,
      imagePath: entity.imagePath,
      description: entity.description,
      isAvailable: entity.isAvailable,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'category': category,
      'rating': rating,
      'review_count': reviewCount,
      'price': price,
      'image_path': imagePath,
      'description': description,
      'is_available': isAvailable,
    };
  }

  MenuItem toEntity() {
    return MenuItem(
      id: id,
      name: name,
      category: category,
      rating: rating,
      reviewCount: reviewCount,
      price: price,
      imagePath: imagePath,
      description: description,
      isAvailable: isAvailable,
    );
  }
}
```

### ğŸ”„ **2.2 Repository Implementation**

**Ø§Ù„Ù…Ù„Ù:** `data/repositories/menu_repository_impl.dart`

```dart
class MenuRepositoryImpl implements MenuRepository {
  final MenuRemoteDataSource remoteDataSource;

  MenuRepositoryImpl({required this.remoteDataSource});

  @override
  Future<List<MenuItem>> getMenuItems() async {
    try {
      final menuItemModels = await remoteDataSource.getMenuItems();
      return menuItemModels.map((model) => model.toEntity()).toList();
    } catch (e) {
      throw Exception('Failed to get menu items: $e');
    }
  }

  @override
  Future<List<MenuItem>> getMenuItemsByCategory(String category) async {
    try {
      final menuItemModels = await remoteDataSource.getMenuItemsByCategory(category);
      return menuItemModels.map((model) => model.toEntity()).toList();
    } catch (e) {
      throw Exception('Failed to get menu items by category: $e');
    }
  }

  @override
  Future<MenuItem?> getMenuItemById(String id) async {
    try {
      final menuItemModel = await remoteDataSource.getMenuItemById(id);
      return menuItemModel?.toEntity();
    } catch (e) {
      throw Exception('Failed to get menu item: $e');
    }
  }

  @override
  Future<MenuItem> updateMenuItem(MenuItem menuItem) async {
    try {
      final menuItemModel = MenuItemModel.fromEntity(menuItem);
      final updatedMenuItemModel = await remoteDataSource.updateMenuItem(menuItemModel);
      return updatedMenuItemModel.toEntity();
    } catch (e) {
      throw Exception('Failed to update menu item: $e');
    }
  }

  @override
  Future<bool> deleteMenuItem(String id) async {
    try {
      return await remoteDataSource.deleteMenuItem(id);
    } catch (e) {
      throw Exception('Failed to delete menu item: $e');
    }
  }

  @override
  Future<List<MenuItem>> searchMenuItems(String query) async {
    try {
      final menuItemModels = await remoteDataSource.searchMenuItems(query);
      return menuItemModels.map((model) => model.toEntity()).toList();
    } catch (e) {
      throw Exception('Failed to search menu items: $e');
    }
  }

  @override
  Future<List<String>> getCategories() async {
    try {
      return await remoteDataSource.getCategories();
    } catch (e) {
      throw Exception('Failed to get categories: $e');
    }
  }
}
```

---

## ğŸ¨ **3. Presentation Layer (Ø·Ø¨Ù‚Ø© Ø§Ù„Ø¹Ø±Ø¶)**

### ğŸ® **3.1 Events (Ù…Ø­Ø³Ù†)**

**Ø§Ù„Ù…Ù„Ù:** `presentation/bloc/menu_events.dart`

```dart
import 'package:equatable/equatable.dart';
import '../../domain/usecases/load_menu_items_by_category_usecase.dart';
import '../../domain/usecases/search_menu_items_usecase.dart';
import '../../domain/usecases/delete_menu_item_usecase.dart';
import '../../domain/usecases/toggle_menu_item_availability_usecase.dart';

// Events
abstract class MenuEvent extends Equatable {
  const MenuEvent();

  @override
  List<Object?> get props => [];
}

class LoadMenuItems extends MenuEvent {}

class LoadMenuItemsByCategory extends MenuEvent {
  final LoadMenuItemsByCategoryParams params;

  const LoadMenuItemsByCategory(this.params);

  @override
  List<Object?> get props => [params];
}

class SearchMenuItems extends MenuEvent {
  final SearchMenuItemsParams params;

  const SearchMenuItems(this.params);

  @override
  List<Object?> get props => [params];
}

class DeleteMenuItem extends MenuEvent {
  final DeleteMenuItemParams params;

  const DeleteMenuItem(this.params);

  @override
  List<Object?> get props => [params];
}

class RefreshMenuItems extends MenuEvent {}

class FilterMenuItems extends MenuEvent {
  final String filterType;
  final dynamic filterValue;

  const FilterMenuItems(this.filterType, this.filterValue);

  @override
  List<Object?> get props => [filterType, filterValue];
}

class SortMenuItems extends MenuEvent {
  final String sortBy;
  final bool ascending;

  const SortMenuItems(this.sortBy, {this.ascending = true});

  @override
  List<Object?> get props => [sortBy, ascending];
}

class LoadMenuCategories extends MenuEvent {}

class ToggleMenuItemAvailability extends MenuEvent {
  final ToggleMenuItemAvailabilityParams params;

  const ToggleMenuItemAvailability(this.params);

  @override
  List<Object?> get props => [params];
}
```

### ğŸ“Š **3.2 States (Ù…Ø­Ø³Ù†)**

**Ø§Ù„Ù…Ù„Ù:** `presentation/bloc/menu_states.dart`

```dart
import 'package:equatable/equatable.dart';
import '../../domain/entities/menu_item.dart';

// States
abstract class MenuState extends Equatable {
  const MenuState();

  @override
  List<Object?> get props => [];
}

class MenuInitial extends MenuState {}

class MenuLoading extends MenuState {}

class MenuItemsLoaded extends MenuState {
  final List<MenuItem> menuItems;
  final String? selectedCategory;
  final List<String> categories;
  final String? searchQuery;
  final String? sortBy;
  final bool ascending;

  const MenuItemsLoaded(
    this.menuItems, {
    this.selectedCategory,
    this.categories = const [],
    this.searchQuery,
    this.sortBy,
    this.ascending = true,
  });

  @override
  List<Object?> get props => [
    menuItems,
    selectedCategory,
    categories,
    searchQuery,
    sortBy,
    ascending,
  ];

  MenuItemsLoaded copyWith({
    List<MenuItem>? menuItems,
    String? selectedCategory,
    List<String>? categories,
    String? searchQuery,
    String? sortBy,
    bool? ascending,
  }) {
    return MenuItemsLoaded(
      menuItems ?? this.menuItems,
      selectedCategory: selectedCategory ?? this.selectedCategory,
      categories: categories ?? this.categories,
      searchQuery: searchQuery ?? this.searchQuery,
      sortBy: sortBy ?? this.sortBy,
      ascending: ascending ?? this.ascending,
    );
  }
}

class MenuItemDeleted extends MenuState {
  final String deletedId;
  final List<MenuItem> remainingItems;

  const MenuItemDeleted(this.deletedId, this.remainingItems);

  @override
  List<Object?> get props => [deletedId, remainingItems];
}

class MenuItemAvailabilityToggled extends MenuState {
  final String itemId;
  final bool isAvailable;

  const MenuItemAvailabilityToggled(this.itemId, this.isAvailable);

  @override
  List<Object?> get props => [itemId, isAvailable];
}

class MenuCategoriesLoaded extends MenuState {
  final List<String> categories;

  const MenuCategoriesLoaded(this.categories);

  @override
  List<Object?> get props => [categories];
}

class MenuSearchResults extends MenuState {
  final List<MenuItem> searchResults;
  final String query;

  const MenuSearchResults(this.searchResults, this.query);

  @override
  List<Object?> get props => [searchResults, query];
}

class MenuFiltered extends MenuState {
  final List<MenuItem> filteredItems;
  final String filterType;
  final dynamic filterValue;

  const MenuFiltered(this.filteredItems, this.filterType, this.filterValue);

  @override
  List<Object?> get props => [filteredItems, filterType, filterValue];
}

class MenuSorted extends MenuState {
  final List<MenuItem> sortedItems;
  final String sortBy;
  final bool ascending;

  const MenuSorted(this.sortedItems, this.sortBy, this.ascending);

  @override
  List<Object?> get props => [sortedItems, sortBy, ascending];
}

class MenuError extends MenuState {
  final String message;
  final String? code;

  const MenuError(this.message, {this.code});

  @override
  List<Object?> get props => [message, code];
}

class MenuValidationError extends MenuState {
  final String message;

  const MenuValidationError(this.message);

  @override
  List<Object?> get props => [message];
}

class MenuAuthError extends MenuState {
  final String message;

  const MenuAuthError(this.message);

  @override
  List<Object?> get props => [message];
}

class MenuEmpty extends MenuState {
  final String? message;
  final String? selectedCategory;

  const MenuEmpty({this.message, this.selectedCategory});

  @override
  List<Object?> get props => [message, selectedCategory];
}
```

### ğŸ¯ **3.3 Cubit (Ù…Ø­Ø³Ù†)**

**Ø§Ù„Ù…Ù„Ù:** `presentation/bloc/menu_cubit.dart`

```dart
import 'package:flutter_bloc/flutter_bloc.dart';
import 'dart:developer';
import '../../domain/entities/menu_item.dart';
import '../../domain/repositories/menu_repository.dart';
import '../../domain/usecases/load_menu_items_usecase.dart';
import '../../domain/usecases/load_menu_items_by_category_usecase.dart';
import '../../domain/usecases/search_menu_items_usecase.dart';
import '../../domain/usecases/delete_menu_item_usecase.dart';
import '../../domain/usecases/toggle_menu_item_availability_usecase.dart';
import 'menu_events.dart';
import 'menu_states.dart';

// Cubit
class MenuCubit extends Bloc<MenuEvent, MenuState> {
  final MenuRepository menuRepository;
  final LoadMenuItemsUseCase loadMenuItemsUseCase;
  final LoadMenuItemsByCategoryUseCase loadMenuItemsByCategoryUseCase;
  final SearchMenuItemsUseCase searchMenuItemsUseCase;
  final DeleteMenuItemUseCase deleteMenuItemUseCase;
  final ToggleMenuItemAvailabilityUseCase toggleMenuItemAvailabilityUseCase;

  MenuCubit({required this.menuRepository})
      : loadMenuItemsUseCase = LoadMenuItemsUseCase(repository: menuRepository),
        loadMenuItemsByCategoryUseCase = LoadMenuItemsByCategoryUseCase(
          repository: menuRepository,
        ),
        searchMenuItemsUseCase = SearchMenuItemsUseCase(
          repository: menuRepository,
        ),
        deleteMenuItemUseCase = DeleteMenuItemUseCase(repository: menuRepository),
        toggleMenuItemAvailabilityUseCase = ToggleMenuItemAvailabilityUseCase(
          repository: menuRepository,
        ),
        super(MenuInitial()) {
    on<LoadMenuItems>(_onLoadMenuItems);
    on<LoadMenuItemsByCategory>(_onLoadMenuItemsByCategory);
    on<SearchMenuItems>(_onSearchMenuItems);
    on<DeleteMenuItem>(_onDeleteMenuItem);
    on<RefreshMenuItems>(_onRefreshMenuItems);
    on<FilterMenuItems>(_onFilterMenuItems);
    on<SortMenuItems>(_onSortMenuItems);
    on<LoadMenuCategories>(_onLoadMenuCategories);
    on<ToggleMenuItemAvailability>(_onToggleMenuItemAvailability);
  }

  /// Get categories from repository
  Future<List<String>> getCategories() async {
    return await menuRepository.getCategories();
  }

  Future<void> _onLoadMenuItems(
    LoadMenuItems event,
    Emitter<MenuState> emit,
  ) async {
    emit(MenuLoading());
    try {
      log('ğŸ”„ MenuCubit: Loading menu items...');
      final menuItems = await loadMenuItemsUseCase();
      final categories = await menuRepository.getCategories();

      log(
        'âœ… MenuCubit: Menu items loaded successfully - ${menuItems.length} items',
      );
      log('âœ… MenuCubit: Categories loaded - ${categories.length} categories');

      emit(MenuItemsLoaded(menuItems, categories: categories));
    } catch (e) {
      log('âŒ MenuCubit: Failed to load menu items - $e');
      _handleError(e, emit);
    }
  }

  Future<void> _onLoadMenuItemsByCategory(
    LoadMenuItemsByCategory event,
    Emitter<MenuState> emit,
  ) async {
    emit(MenuLoading());
    try {
      log(
        'ğŸ”„ MenuCubit: Loading menu items for category: ${event.params.category}',
      );
      final menuItems = await loadMenuItemsByCategoryUseCase(event.params);
      final categories = await menuRepository.getCategories();

      log(
        'âœ… MenuCubit: Menu items loaded for category - ${menuItems.length} items',
      );

      if (menuItems.isEmpty) {
        emit(
          MenuEmpty(
            message: 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù†ØªØ¬Ø§Øª ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„ÙØ¦Ø©',
            selectedCategory: event.params.category,
          ),
        );
      } else {
        emit(
          MenuItemsLoaded(
            menuItems,
            selectedCategory: event.params.category,
            categories: categories,
          ),
        );
      }
    } catch (e) {
      log('âŒ MenuCubit: Failed to load menu items by category - $e');
      _handleError(e, emit);
    }
  }

  Future<void> _onSearchMenuItems(
    SearchMenuItems event,
    Emitter<MenuState> emit,
  ) async {
    emit(MenuLoading());
    try {
      log(
        'ğŸ”„ MenuCubit: Searching menu items with query: ${event.params.query}',
      );
      final menuItems = await searchMenuItemsUseCase(event.params);
      log('âœ… MenuCubit: Search completed - ${menuItems.length} items found');

      if (menuItems.isEmpty) {
        emit(MenuSearchResults([], event.params.query));
      } else {
        emit(MenuSearchResults(menuItems, event.params.query));
      }
    } catch (e) {
      log('âŒ MenuCubit: Failed to search menu items - $e');
      _handleError(e, emit);
    }
  }

  Future<void> _onDeleteMenuItem(
    DeleteMenuItem event,
    Emitter<MenuState> emit,
  ) async {
    try {
      log('ğŸ”„ MenuCubit: Deleting menu item with id: ${event.params.id}');
      final success = await deleteMenuItemUseCase(event.params);

      if (success) {
        log('âœ… MenuCubit: Menu item deleted successfully');
        // Reload menu items after deletion
        final menuItems = await loadMenuItemsUseCase();
        emit(MenuItemDeleted(event.params.id, menuItems));
      } else {
        emit(MenuError('ÙØ´Ù„ ÙÙŠ Ø­Ø°Ù Ø§Ù„Ù…Ù†ØªØ¬'));
      }
    } catch (e) {
      log('âŒ MenuCubit: Failed to delete menu item - $e');
      _handleError(e, emit);
    }
  }

  Future<void> _onRefreshMenuItems(
    RefreshMenuItems event,
    Emitter<MenuState> emit,
  ) async {
    emit(MenuLoading());
    try {
      log('ğŸ”„ MenuCubit: Refreshing menu items...');
      final menuItems = await loadMenuItemsUseCase();
      final categories = await menuRepository.getCategories();

      log('âœ… MenuCubit: Menu items refreshed - ${menuItems.length} items');
      emit(MenuItemsLoaded(menuItems, categories: categories));
    } catch (e) {
      log('âŒ MenuCubit: Failed to refresh menu items - $e');
      _handleError(e, emit);
    }
  }

  Future<void> _onFilterMenuItems(
    FilterMenuItems event,
    Emitter<MenuState> emit,
  ) async {
    try {
      log('ğŸ”„ MenuCubit: Filtering menu items by ${event.filterType}');
      final allItems = await loadMenuItemsUseCase();
      List<MenuItem> filteredItems = [];

      switch (event.filterType) {
        case 'category':
          filteredItems = allItems
              .where((item) => item.category == event.filterValue)
              .toList();
          break;
        case 'price':
          final maxPrice = double.tryParse(event.filterValue.toString()) ?? 0.0;
          filteredItems = allItems.where((item) {
            final itemPrice = double.tryParse(item.price) ?? 0.0;
            return itemPrice <= maxPrice;
          }).toList();
          break;
        case 'availability':
          final isAvailable = event.filterValue as bool;
          filteredItems = allItems
              .where((item) => item.isAvailable == isAvailable)
              .toList();
          break;
        default:
          filteredItems = allItems;
      }

      log('âœ… MenuCubit: Filtered items - ${filteredItems.length} items');
      emit(MenuFiltered(filteredItems, event.filterType, event.filterValue));
    } catch (e) {
      log('âŒ MenuCubit: Failed to filter menu items - $e');
      _handleError(e, emit);
    }
  }

  Future<void> _onSortMenuItems(
    SortMenuItems event,
    Emitter<MenuState> emit,
  ) async {
    try {
      log('ğŸ”„ MenuCubit: Sorting menu items by ${event.sortBy}');
      final allItems = await loadMenuItemsUseCase();
      List<MenuItem> sortedItems = [];

      switch (event.sortBy) {
        case 'name':
          sortedItems = List.from(allItems)
            ..sort(
              (a, b) => event.ascending
                  ? a.name.compareTo(b.name)
                  : b.name.compareTo(a.name),
            );
          break;
        case 'price':
          sortedItems = List.from(allItems)
            ..sort((a, b) {
              final priceA = double.tryParse(a.price) ?? 0.0;
              final priceB = double.tryParse(b.price) ?? 0.0;
              return event.ascending
                  ? priceA.compareTo(priceB)
                  : priceB.compareTo(priceA);
            });
          break;
        case 'rating':
          sortedItems = List.from(allItems)
            ..sort(
              (a, b) => event.ascending
                  ? a.rating.compareTo(b.rating)
                  : b.rating.compareTo(a.rating),
            );
          break;
        default:
          sortedItems = allItems;
      }

      log('âœ… MenuCubit: Sorted items - ${sortedItems.length} items');
      emit(MenuSorted(sortedItems, event.sortBy, event.ascending));
    } catch (e) {
      log('âŒ MenuCubit: Failed to sort menu items - $e');
      _handleError(e, emit);
    }
  }

  Future<void> _onLoadMenuCategories(
    LoadMenuCategories event,
    Emitter<MenuState> emit,
  ) async {
    try {
      log('ğŸ”„ MenuCubit: Loading menu categories...');
      final categories = await menuRepository.getCategories();
      log('âœ… MenuCubit: Categories loaded - ${categories.length} categories');
      emit(MenuCategoriesLoaded(categories));
    } catch (e) {
      log('âŒ MenuCubit: Failed to load categories - $e');
      _handleError(e, emit);
    }
  }

  Future<void> _onToggleMenuItemAvailability(
    ToggleMenuItemAvailability event,
    Emitter<MenuState> emit,
  ) async {
    try {
      log('ğŸ”„ MenuCubit: Toggling availability for item: ${event.params.id}');
      final updatedItem = await toggleMenuItemAvailabilityUseCase(event.params);
      log('âœ… MenuCubit: Availability toggled successfully');
      emit(
        MenuItemAvailabilityToggled(event.params.id, event.params.isAvailable),
      );
    } catch (e) {
      log('âŒ MenuCubit: Failed to toggle availability - $e');
      _handleError(e, emit);
    }
  }

  void _handleError(dynamic error, Emitter<MenuState> emit) {
    final errorMessage = error.toString();

    if (errorMessage.contains('Ø§Ø³Ù… Ø§Ù„ÙØ¦Ø©') ||
        errorMessage.contains('Ù†Øµ Ø§Ù„Ø¨Ø­Ø«') ||
        errorMessage.contains('Ù…Ø¹Ø±Ù Ø§Ù„Ù…Ù†ØªØ¬')) {
      emit(MenuValidationError(errorMessage));
    } else if (errorMessage.contains('ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„') ||
        errorMessage.contains('ØºÙŠØ± Ù…ØµØ±Ø­')) {
      emit(MenuAuthError(errorMessage));
    } else {
      emit(MenuError(errorMessage));
    }
  }
}
```

### ğŸ¨ **3.4 UI Components**

**Ø§Ù„Ù…Ù„Ù:** `presentation/pages/admin_menu_page.dart`

```dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../bloc/menu_events.dart';
import '../bloc/menu_states.dart';
import '../widgets/menu_filter_tabs.dart';
import '../widgets/menu_item_card.dart';
import '../bloc/menu_cubit.dart';
import '../../domain/entities/menu_item.dart';
import '../../domain/usecases/load_menu_items_by_category_usecase.dart';
import '../../domain/usecases/search_menu_items_usecase.dart';
import '../../domain/usecases/delete_menu_item_usecase.dart';
import '../../domain/usecases/toggle_menu_item_availability_usecase.dart';
import '../../../../../../../core/di/service_locator.dart';

class AdminMenuPage extends StatefulWidget {
  const AdminMenuPage({super.key});

  @override
  State<AdminMenuPage> createState() => _AdminMenuPageState();
}

class _AdminMenuPageState extends State<AdminMenuPage> {
  int _selectedCategoryIndex = 0;
  List<String> _categories = ['All'];
  bool _isLoadingCategories = false;

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => getIt<MenuCubit>()..add(LoadMenuItems()),
      child: BlocListener<MenuCubit, MenuState>(
        listener: (context, state) {
          if (state is MenuError) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Ø®Ø·Ø£: ${state.message}'),
                backgroundColor: Colors.red,
              ),
            );
          } else if (state is MenuItemDeleted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('ØªÙ… Ø­Ø°Ù Ø§Ù„Ù…Ù†ØªØ¬ Ø¨Ù†Ø¬Ø§Ø­'),
                backgroundColor: Colors.green,
              ),
            );
          }
        },
        child: BlocBuilder<MenuCubit, MenuState>(
          builder: (context, state) {
            return Scaffold(
              backgroundColor: Colors.white,
              body: SafeArea(
                child: Column(
                  children: [
                    _buildHeader(),
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      child: _isLoadingCategories
                          ? const Center(child: CircularProgressIndicator())
                          : MenuFilterTabs(
                              categories: _categories,
                              selectedIndex: _selectedCategoryIndex,
                              onCategorySelected: (index) {
                                setState(() {
                                  _selectedCategoryIndex = index;
                                });
                                final cubit = context.read<MenuCubit>();
                                if (index == 0) {
                                  cubit.add(LoadMenuItems());
                                } else {
                                  cubit.add(
                                    LoadMenuItemsByCategory(
                                      LoadMenuItemsByCategoryParams(
                                        category: _categories[index],
                                      ),
                                    ),
                                  );
                                }
                              },
                            ),
                    ),
                    const SizedBox(height: 16),
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 16),
                      child: Row(
                        children: [
                          Text(
                            _buildItemsCountText(state),
                            style: TextStyle(
                              fontSize: 14,
                              color: Colors.grey[600],
                            ),
                          ),
                        ],
                      ),
                    ),
                    const SizedBox(height: 16),
                    Expanded(child: _buildMenuItemsList(state)),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  // ... Ø¨Ø§Ù‚ÙŠ Ø§Ù„Ø£Ø³Ø§Ù„ÙŠØ¨
}
```

---

## ğŸ¯ **Ø§Ù„Ù…Ø²Ø§ÙŠØ§ Ø§Ù„Ù…Ø­Ù‚Ù‚Ø© Ù…Ù† Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª**

### âœ… **1. ÙØµÙ„ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ§Øª:**
- **UI**: Ø¹Ø±Ø¶ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙÙ‚Ø·
- **Cubit**: State Management
- **UseCase**: Business Logic + Validation
- **Repository**: Data Access

### âœ… **2. ØªØ­Ø³ÙŠÙ† Error Handling:**
```dart
// âœ… Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø®Ø·Ø§Ø¡ Ù…Ø®ØªÙ„ÙØ©
if (state is MenuValidationError) {
  // Ø¹Ø±Ø¶ Ø£Ø®Ø·Ø§Ø¡ validation
} else if (state is MenuAuthError) {
  // Ø¹Ø±Ø¶ Ø£Ø®Ø·Ø§Ø¡ authentication
} else if (state is MenuError) {
  // Ø¹Ø±Ø¶ Ø£Ø®Ø·Ø§Ø¡ Ø¹Ø§Ù…Ø©
}
```

### âœ… **3. Ø³Ù‡ÙˆÙ„Ø© Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±:**
```dart
// âœ… ÙŠÙ…ÙƒÙ† Ø§Ø®ØªØ¨Ø§Ø± UseCase Ù…Ù†ÙØµÙ„
test('should load menu items by category correctly', () {
  final useCase = LoadMenuItemsByCategoryUseCase(mockRepository);
  final params = LoadMenuItemsByCategoryParams(category: 'Pizza');
  
  expect(() => useCase(params), returnsNormally);
});
```

### âœ… **4. Ø§ØªØ¨Ø§Ø¹ Clean Architecture:**
```
UI â†’ Cubit â†’ UseCase â†’ Repository â†’ Model â†” Entity
```

### âœ… **5. ØªÙ‚Ù„ÙŠÙ„ Ø§Ù„ØªÙƒØ±Ø§Ø±:**
- **Ù‚Ø¨Ù„:** Business Logic ÙÙŠ Cubit
- **Ø¨Ø¹Ø¯:** Business Logic ÙÙŠ UseCase ÙÙ‚Ø·

---

## ğŸš€ **Ø§Ù„Ø®Ù„Ø§ØµØ©**

ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª Ø¨Ù†Ø¬Ø§Ø­! Ø§Ù„Ø¢Ù† Ø§Ù„ÙƒÙˆØ¯:

- âœ… **Ù…Ù†Ø¸Ù… ÙˆÙ…ÙØµÙ„** Ø¨ÙŠÙ† Ø§Ù„Ø·Ø¨Ù‚Ø§Øª
- âœ… **Ø³Ù‡Ù„ Ø§Ù„Ø§Ø®ØªØ¨Ø§Ø±** ÙˆØ§Ù„ØµÙŠØ§Ù†Ø©
- âœ… **ÙŠØªØ¨Ø¹ Clean Architecture**
- âœ… **ÙŠØ­Ø³Ù† ØªØ¬Ø±Ø¨Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…**

**Ø§Ù„Ù…ÙØªØ§Ø­ Ù„Ù„Ù†Ø¬Ø§Ø­:** Ø§ØªØ¨Ø¹ Clean Architecture ÙˆÙØµÙ„ Ø§Ù„Ù…Ø³Ø¤ÙˆÙ„ÙŠØ§Øª Ø¨ÙŠÙ† Ø§Ù„Ø·Ø¨Ù‚Ø§Øª! ğŸš€ 